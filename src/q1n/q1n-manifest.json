{
    "id": "q1n-net-streaming-provider",
    "name": "Q1N.net Streaming Provider",
    "description": "Provedor de streaming para Q1N.net - anime legendado, dublado e donghua",
    "manifestURI": "",
    "version": "1.0.0",
    "author": "Plugin Community",
    "type": "onlinestream-provider",
    "language": "typescript",
    "lang": "pt",
    "payload": "/// <reference path=\"./online-streaming-provider.d.ts\" />\n/// <reference path=\"./core.d.ts\" />\n\ninterface Q1NAnimeResult {\n    title: string;\n    url: string;\n    poster?: string;\n    year?: number;\n    type?: string;\n}\n\ninterface Q1NEpisode {\n    number: number;\n    title?: string;\n    url: string;\n    date?: string;\n}\n\nclass Provider {\n    \n    api = \"https://q1n.net\"\n    \n    getSettings(): Settings {\n        return {\n            episodeServers: [\"chplay\", \"ruplay\"],\n            supportsDub: true,\n        }\n    }\n\n    async search(opts: SearchOptions): Promise<SearchResult[]> {\n        try {\n            const searchUrl = `${this.api}/?s=${encodeURIComponent(opts.query)}`\n            const response = await fetch(searchUrl)\n            \n            if (!response.ok) {\n                return []\n            }\n            \n            const html = await response.text()\n            const $ = LoadDoc(html)\n            \n            const results: SearchResult[] = []\n            \n            $(\"article\").each((_, element) => {\n                const titleEl = element.find(\"h2 a\").first()\n                const title = titleEl.text().trim()\n                const url = titleEl.attr(\"href\")\n                \n                if (title && url && url.includes(\"/animes/\")) {\n                    let subOrDub: SubOrDub = \"sub\"\n                    if (title.toLowerCase().includes(\"dublado\") || title.toLowerCase().includes(\"dub\")) {\n                        subOrDub = \"dub\"\n                    }\n                    \n                    results.push({\n                        id: this.extractIdFromUrl(url),\n                        title: title,\n                        url: url,\n                        subOrDub: subOrDub,\n                    })\n                }\n            })\n            \n            return results\n            \n        } catch (error) {\n            console.error(\"Erro na busca:\", error)\n            return []\n        }\n    }\n\n    async findEpisodes(id: string): Promise<EpisodeDetails[]> {\n        try {\n            const animeUrl = `${this.api}/animes/${id}/`\n            const response = await fetch(animeUrl)\n            \n            if (!response.ok) {\n                return []\n            }\n            \n            const html = await response.text()\n            const $ = LoadDoc(html)\n            \n            const episodes: EpisodeDetails[] = []\n            \n            $(\"ul.episodios li\").each((_, element) => {\n                const epLink = element.find(\".episodiotitle a\").first()\n                const epUrl = epLink.attr(\"href\")\n                \n                if (epUrl) {\n                    const epNumberMatch = epUrl.match(/episodio-(\\d+)/)\n                    const epNumber = epNumberMatch ? parseInt(epNumberMatch[1]) : episodes.length + 1\n                    \n                    const epTitle = epLink.text().trim() || `Episódio ${epNumber}`\n                    \n                    episodes.push({\n                        id: this.extractEpisodeIdFromUrl(epUrl),\n                        number: epNumber,\n                        url: epUrl,\n                        title: epTitle,\n                    })\n                }\n            })\n            \n            if (episodes.length === 0) {\n                return this.findEpisodesFromEpisodePage(id)\n            }\n            \n            return episodes.sort((a, b) => a.number - b.number)\n            \n        } catch (error) {\n            console.error(\"Erro ao buscar episódios:\", error)\n            return []\n        }\n    }\n    \n    private async findEpisodesFromEpisodePage(animeId: string): Promise<EpisodeDetails[]> {\n        const episodes: EpisodeDetails[] = []\n        \n        for (let i = 1; i <= 50; i++) {\n            try {\n                const episodeUrl = `${this.api}/episodio/${animeId}-episodio-${i}/`\n                const response = await fetch(episodeUrl, { method: 'HEAD' })\n                \n                if (response.ok) {\n                    episodes.push({\n                        id: `${animeId}-episodio-${i}`,\n                        number: i,\n                        url: episodeUrl,\n                        title: `Episódio ${i}`,\n                    })\n                } else if (i > 1) {\n                    break\n                }\n            } catch {\n                break\n            }\n        }\n        \n        return episodes\n    }\n\n    async findEpisodeServer(episode: EpisodeDetails, server: string): Promise<EpisodeServer> {\n        try {\n            const response = await fetch(episode.url)\n            \n            if (!response.ok) {\n                throw new Error(\"Não foi possível carregar a página do episódio\")\n            }\n            \n            const html = await response.text()\n            const $ = LoadDoc(html)\n            \n            const result: EpisodeServer = {\n                server: server === \"default\" ? \"chplay\" : server,\n                headers: {},\n                videoSources: [],\n            }\n            \n            const players = new Map<string, string>()\n            \n            $(\"iframe\").each((_, iframe) => {\n                const src = iframe.attr(\"src\")\n                if (src && src.trim() !== \"\") {\n                    if (src.includes(\"chplay\") || src.includes(\"cp.php\")) {\n                        players.set(\"chplay\", src)\n                    } else if (src.includes(\"ruplay\") || src.includes(\"rp.php\")) {\n                        players.set(\"ruplay\", src)\n                    } else {\n                        players.set(\"default\", src)\n                    }\n                }\n            })\n            \n            const targetServer = server === \"default\" ? \"chplay\" : server\n            let playerUrl = players.get(targetServer) || players.get(\"chplay\") || players.get(\"default\") || players.values().next().value\n            \n            if (playerUrl && playerUrl.trim() !== \"\") {\n                result.videoSources.push({\n                    url: playerUrl,\n                    type: \"mp4\",\n                    quality: \"720p\",\n                    subtitles: [],\n                })\n                \n                result.headers = {\n                    \"Referer\": this.api,\n                    \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36\",\n                }\n            }\n            \n            if (result.videoSources.length === 0) {\n                throw new Error(\"Nenhuma fonte de vídeo encontrada\")\n            }\n            \n            return result\n            \n        } catch (error) {\n            console.error(\"Erro ao buscar servidor do episódio:\", error)\n            throw error\n        }\n    }\n    \n    private extractIdFromUrl(url: string): string {\n        const match = url.match(/animes\\/([^\\/]+)/) || url.match(/\\/([^\\/]+)\\/?$/)\n        return match ? match[1] : url\n    }\n    \n    private extractEpisodeIdFromUrl(url: string): string {\n        const match = url.match(/episodio\\/([^\\/]+)/) || url.match(/\\/([^\\/]+)\\/?$/)\n        return match ? match[1] : url\n    }\n}"
}